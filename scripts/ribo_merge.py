#!/usr/bin/env python
'''This script takes n number of input files generated by
ribosome profiling and creates a new data frame containing only
the uORF information and writes it as csv and bed6 format files.
If multiple uORFs are overlapping, the longest is selected.
Multiple non-overlapping uORFs on a transcript recieve a unique id.
'''

import pandas as pd
import re
import argparse
import numpy as np
import os

# function to read in ribosome profiling output files ORFs_max_filt
def create_table(name):
    df = pd.read_table(name)
    return df


# function to select only uORFs
def keep_uORFs(df):
    df = create_table(df)
    df_uORFs = df[(df["TisType"] == "5'UTR") | (df["TisType"] == "5'UTR:CDSFrameOverlap")]
    return df_uORFs

#Gid	Tid	Symbol	GeneType	GenomePos	StartCodon	Start	Stop	TisType	TISGroup	TISCounts	TISPvalue	RiboPvalue	RiboPStatus	FisherPvalue	TISQvalue	FrameQvalue	FisherQvalue	AALen
# function to keep only certain columns
def drop_cols(df_uORFs):
    df_uORFs = keep_uORFs(df_uORFs)
    #df_dropped = df_uORFs[["Gid", "GenType", "StartCodon", "TISCounts", "TISPvalue", "RiboPvalue", "RiboPStatus", "FisherPvalue", "TISQvalue", "FrameQvalue", "FisherQvalue", "AALen"]]
    df_dropped = df_uORFs[["GenomePos", "AALen", "Gid", "Symbol", "Tid"]]
    df_dropped.columns = ["ORF_id_gen", "ORF_length", "gene_id", "gene_symbol", "transcript_id"]
    return df_dropped

#Tid	Symbol	GenomePos	StartCodon	Start	Stop	TisType	TISGroup	TISCounts

# function to get chromosome name
def chrom_name(column):
    chrom = []
    for i in column:
        match = re.findall("chr[0-9MXY]+", i)
        for a in match:
            chrom.append(a)
    return chrom


# function to get start position
def start(column):
    start = []
    for i in column:
        match = re.findall(":([0-9]+)-", i)
        for a in match:
            startstring = str(int(a)+1)
            start.append(startstring)
    return start


# function to get stop position
def stop(column):
    stop = []
    for i in column:
        match = re.findall("-([0-9]+):", i)
        for a in match:
            stopstring = str(int(a))
            stop.append(stopstring)
    return stop

def strand(column):
    strand = []
    for i in column:
        match = re.findall(":([+-])$", i)
        for a in match:
            strand.append(a)
    return strand


# function to create final data frame
def create_output(args):
    #rearrange column

    df_final = pd.DataFrame(columns=["ORF_id_gen","chromosome","start","stop","gene_id","gene_symbol","strand","ORF_length","transcript_id"])
    # Create data frame from all input files
    for name in args.ribotish_files:
        #for nonempty files
        if os.stat(name).st_size != 0:
            print(name)
            #read file into dataframe and drop columns not of interest
            df_sub = drop_cols(name)
            # rename columns to chromosome, start, and stop
            df_sub["strand"] = strand(df_sub["ORF_id_gen"])
            df_sub["chromosome"] = chrom_name(df_sub["ORF_id_gen"])
            df_sub["start"] = start(df_sub["ORF_id_gen"])
            df_sub["stop"] = stop(df_sub["ORF_id_gen"])
            
            df_dropped = df_sub[["ORF_id_gen","chromosome","start","stop","gene_id","gene_symbol","strand","ORF_length","transcript_id"]]
            for new_index, new_row in df_dropped.iterrows():
                 #check if entry with overlapping coordinates already exists
                 orf_range = range((int(new_row.start)), (int(new_row.stop)))
                 orf_set = set(orf_range)
                 orf_length = int(new_row.stop) - int(new_row.start)
                 intersection_switch = False
                 #intersecting_row = ""
                 #intersecting_gene_length = 0
                 #intersecting_gene_index = 0
                 if len(df_final) != 0:
                     current_index = len(df_final)
                     df_final.loc[current_index] = new_row
                 else:
                     current_index = 0
                     df_final.loc[current_index] = new_row
                 #for index, row in df_final.iterrows():
                 #  oorf_range = range((int(row.start)), (int(row.stop)))
                #    oorf_set = set(oorf_range)
                #    oorf_length = int(row.stop) - int(row.start)
                #    intersect = orf_set.intersection(oorf_set)
                #    #intersecting entry found, store it
                #    if row.chromosome == new_row.chromosome:
                #          if intersect:
                #             intersection_switch = True
                #             intersecting_row = new_row
                #             intersecting_gene_length = oorf_length
                #             intersecting_gene_index = index
#
                 #If not intersecting add row to the existing dataframe
                 #if not intersection_switch:
                 #      if len(df_final) != 0:
                #        current_index = len(df_final)
                #        df_final.loc[current_index] = new_row
                #      else:
                #         current_index = 0
                #         df_final.loc[current_index] = new_row
                 #else:
                     #if the gene is intersecting and longer than the already stored orf it is replaced
                #     if orf_length > intersecting_gene_length:
                         #print("intersected")
                         #print(intersecting_gene_index)
                         #print(intersecting_row)
                #         df_final.loc[intersecting_gene_index] = intersecting_row

            # Cleaning up data frame
            df_final.drop_duplicates(subset="ORF_id_gen", inplace=True)
            df_final.reset_index(inplace=True)
            df_final.drop(["index"], axis=1, inplace=True)


            # Filter min and max uORF lengths
            if args.min_length is not None:
                print("Length filterset to min: " + args.min_length)
                df_final = df_final[df_final['ORF_length'] >= int(args.min_length)]

            if args.max_length is not None:
                print("Length filterset to max: " + args.max_length)
                df_final = df_final[df_final['ORF_length'] <= int(args.max_length)]
    return df_final

def set_uORFids(args):
        tid_dict = {}
        uORFids = []
        for index, row in args.iterrows():
            if row.transcript_id in tid_dict:
                current_tindex=tid_dict[row.transcript_id]
                next_tindex=current_tindex + 1 
                tid_dict[row.transcript_id]=next_tindex
            else:
                next_tindex = 1
                tid_dict[row.transcript_id] = next_tindex
            uORFid = row.transcript_id + '.' + str(next_tindex)
            uORFids.append(uORFid)
        m = np.asarray(uORFids)
        args["uORFids"]=m
        return(args)

def make_uORFs_bed(args):
    uORFsString = ""
    for index, row in args.iterrows():
        uORFString=row.chromosome + "\t" + row.start + "\t" + row.stop + "\t" + row.uORFids + "\t0\t" + row.strand + "\n"
        uORFsString= uORFsString + uORFString
    return(uORFsString)

def main():
    # store commandline args
    parser = argparse.ArgumentParser(description='Converts ribotish output to new data frame\
                                     containing only the uORF information.')
    parser.add_argument('ribotish_files', nargs='*', metavar='ribotish', help='Path to ribotish ORF file (ORFs_max_filt)')
    parser.add_argument("--output_csv_filepath", help='Path to write \
                        merged csv output')
    parser.add_argument("--output_bed_filepath", help='Path to write \
                        merged bed6 output')
    parser.add_argument("--min_length", default=None, help='Minimal uORF \
                        length')
    parser.add_argument("--max_length", default=None, help='Maximal uORF \
                        length')
    args = parser.parse_args()
    # make sure that min_length and max_length are given
    uorfsframe = create_output(args)
    # get some general info on output
    #print(output.describe(include='all'))
    # write output to csv file
    uORFsdf=set_uORFids(uorfsframe)
    uORFsdf.to_csv(args.output_csv_filepath)
    uORFsbed=make_uORFs_bed(uORFsdf)
    f = open(args.output_bed_filepath, 'wt', encoding='utf-8')
    f.write(uORFsbed)

if __name__ == '__main__':
    main()
