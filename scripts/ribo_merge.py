#!/usr/bin/env python
'''This script takes n number of input files generated by
ribosome profiling and creates a new data frame containing only
the uORF information and writes it as csv and bed6 format files.
'''

import pandas as pd
import re
import argparse
import numpy as np
import os

# function to read in ribosome profiling output files ORFs_max_filt
def create_table(name):
    df = pd.read_table(name)
    return df


# function to select only uORFs
def keep_uORFs(df):
    df = create_table(df)
    df_uORFs = df[df["category"] == "uORF"]
    return df_uORFs


# function to keep only certain columns
def drop_cols(df_uORFs):
    df_uORFs = keep_uORFs(df_uORFs)
    df_dropped = df_uORFs[["gene_id", "gene_symbol", "transcript_id", \
                           "strand", "ORF_id_gen", 'ORF_length']]
    return df_dropped


# function to get chromosome name
def chrom_name(column):
    chrom = []
    for i in column:
        match = re.findall("chr[0-9MXY]+", i)
        for a in match:
            chrom.append(a)
    return chrom


# function to get start position
def start(column):
    start = []
    for i in column:
        match = re.findall("_(.+)_", i)
        for a in match:
            start.append(a)
    return start


# function to get stop position
def stop(column):
    stop = []
    for i in column:
        match = re.findall("_([0-9]+)$", i)
        for a in match:
            stop.append(a)
    return stop


# function to create final data frame
def create_output(args):
    # create empty data frame to append to later
    df_final = pd.DataFrame(columns=["ORF_id_gen","ORF_length","chromosome","gene_id","gene_symbol","start","stop","strand","transcript_id"])
    # Create data frame from all input files
    for name in args.ribotish_files:
        #for nonempty files
        if os.stat(name).st_size != 0:
            print(name)
            #read file into dataframe and drop columns not of interest
            df_sub = drop_cols(name)
            # rename columns to chromosome, start, and stop
            df_sub["chromosome"] = chrom_name(df_sub["ORF_id_gen"])
            df_sub["start"] = start(df_sub["ORF_id_gen"])
            df_sub["stop"] = stop(df_sub["ORF_id_gen"])
            for new_index, new_row in df_sub.iterrows():
                 #check if entry with overlapping coordinates already exists
                 orf_range = range((int(new_row.start) -1), (int(new_row.stop) + 1))
                 orf_set = set(orf_range)
                 orf_length = int(new_row.stop) - int(new_row.start)
                 intersection_switch = False
                 intersecting_row = ""
                 intersecting_gene_length = 0
                 intersecting_gene_index = 0
                 for index, row in df_final.iterrows():
                     oorf_range = range((int(row.start) - 1), (int(row.stop) + 1))
                     oorf_set = set(oorf_range)
                     oorf_length = int(row.stop) - int(row.start)
                     intersect = orf_set.intersection(oorf_set)
                     #intersecting entry found, store it
                     if row.chromosome == new_row.chromosome:
                         if intersect:
                             intersection_switch = True
                             intersecting_row = new_row
                             intersecting_gene_length = oorf_length
                             intersecting_gene_index = index

                 #If not intersecting add row to the existing dataframe        
                 if not intersection_switch:
                     if len(df_final) != 0:
                        current_index = len(df_final)
                        #print(current_index)
                        #print(new_row)
                        df_final.loc[current_index] = new_row
                     else:
                         current_index = 0 
                         df_final.loc[current_index] = new_row
                 else:
                     #if the gene is intersecting and longer than the already stored orf it is replaced
                     if orf_length > intersecting_gene_length:
                         #print("intersected")
                         #print(intersecting_gene_index)
                         #print(intersecting_row)
                         df_final.loc[intersecting_gene_index] = intersecting_row

            # Cleaning up data frame
            df_final.drop_duplicates(subset="ORF_id_gen", inplace=True)
            df_final.reset_index(inplace=True)
            df_final.drop(["index"], axis=1, inplace=True)


            # Filter min and max uORF lengths
            if args.min_length is not None:
                print("Length filterset to min: " + args.min_length)
                df_final = df_final[df_final['ORF_length'] >= int(args.min_length)]

            if args.max_length is not None:
                print("Length filterset to max: " + args.max_length)
                df_final = df_final[df_final['ORF_length'] <= int(args.max_length)]
    return df_final

def set_uORFids(args):
        tid_dict = {}
        uORFids = []
        for index, row in args.iterrows():
            if row.transcript_id in tid_dict:
                tindex=tid_dict[row.transcript_id]
                tid_dict[row.transcript_id]=tindex + 1
            else:
                tindex = 1
                tid_dict[row.transcript_id] = tindex
            uORFid = row.transcript_id + '.' + str(tindex)
            uORFids.append(uORFid)
        m = np.asarray(uORFids)
        args["uORFids"]=m
        return(args)

def make_uORFs_bed(args):
    uORFsString = ""
    for index, row in args.iterrows():
        uORFString=row.chromosome + "\t" + row.start + "\t" + row.stop + "\t" + row.uORFids + "\t0\t" + row.strand + "\n"
        uORFsString= uORFsString + uORFString
    return(uORFsString)

def main():
    # store commandline args
    parser = argparse.ArgumentParser(description='Converts ribotish output to new data frame\
                                     containing only the uORF information.')
    parser.add_argument('ribotish_files', nargs='*', metavar='ribotish', help='Path to ribotish ORF file (ORFs_max_filt)')
    parser.add_argument("--output_csv_filepath", help='Path to write \
                        merged csv output')
    parser.add_argument("--output_bed_filepath", help='Path to write \
                        merged bed6 output')
    parser.add_argument("--min_length", default=None, help='Minimal uORF \
                        length')
    parser.add_argument("--max_length", default=None, help='Maximal uORF \
                        length')
    args = parser.parse_args()
    # make sure that min_length and max_length are given
    uorfsframe = create_output(args)
    # get some general info on output
    #print(output.describe(include='all'))
    # write output to csv file
    uorfsframe.to_csv(args.output_csv_filepath)
    uORFsdf=set_uORFids(uorfsframe)
    uORFsbed=make_uORFs_bed(uORFsdf)
    f = open(args.output_bed_filepath, 'wt', encoding='utf-8')
    f.write(uORFsbed)
    

if __name__ == '__main__':
    main()
